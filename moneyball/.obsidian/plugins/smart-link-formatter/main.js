/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source visit the plugins github repository
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => SmartLinkFormatterPlugin,
  escapeMarkdownChars: () => escapeMarkdownChars
});
var import_obsidian3 = __toModule(require("obsidian"));

// settings.ts
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  printCommand: "[{title}] by {channel}",
  autoLink: true,
  blacklistedDomains: "",
  defaultLinkFormat: "[{title}]({link})"
};
var LinkFormatterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Auto-linking").setDesc("Automatically format links when pasting URLs. Disable this to paste URLs without formatting.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoLink).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoLink = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Default link format").setDesc("Format for non-YouTube links. Use {title} for page title and {link} for URL. Example: [{title}]").addTextArea((text) => text.setPlaceholder("[{title}]").setValue(this.plugin.settings.defaultLinkFormat).then((textArea) => {
      textArea.inputEl.rows = 2;
      textArea.inputEl.addClass("smart-link-formatter-setting-textarea");
    }).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.defaultLinkFormat = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Blacklisted domains").setDesc("Comma-separated list of domains that should never be auto-formatted. URLs from these domains will be pasted as-is.").addTextArea((text) => text.setPlaceholder("example.com, test.org").setValue(this.plugin.settings.blacklistedDomains).then((textArea) => {
      textArea.inputEl.rows = 2;
      textArea.inputEl.addClass("smart-link-formatter-setting-textarea");
    }).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.blacklistedDomains = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("YouTube link format").setDesc("Customize how YouTube links are formatted. Available variables: {title}, {channel}, {uploader}, {duration}, {views}, {upload_date}, {description}, {url}, {timestamp}. Example: [{title}] by {channel}").addTextArea((text) => text.setPlaceholder(DEFAULT_SETTINGS.printCommand).setValue(this.plugin.settings.printCommand).then((textArea) => {
      textArea.inputEl.rows = 4;
      textArea.inputEl.cols = 50;
      textArea.inputEl.addClass("smart-link-formatter-setting-textarea");
    }).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.printCommand = value;
      yield this.plugin.saveSettings();
    })));
  }
};

// title-utils.ts
var import_obsidian2 = __toModule(require("obsidian"));
function blank(text) {
  return text === void 0 || text === null || text === "";
}
function getUrlFinalSegment(url) {
  try {
    const urlObject = new URL(url);
    const segments = urlObject.pathname.split("/");
    const nonEmptySegments = segments.filter((segment) => segment.length > 0);
    const last = nonEmptySegments.pop();
    return last || "File";
  } catch (_) {
    return url;
  }
}
function loadElectronWindow(window, url) {
  return __async(this, null, function* () {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        console.warn(`Smart Link Formatter: Timeout loading ${url} in Electron window.`);
        try {
          if (window && !window.isDestroyed()) {
            window.webContents.stop();
          }
        } catch (err) {
        }
        reject(new Error(`Timeout loading URL: ${url}`));
      }, 3e4);
      const didFinishLoad = () => {
        clearTimeout(timer);
        window.webContents.removeListener("did-finish-load", didFinishLoad);
        window.webContents.removeListener("did-fail-load", didFailLoad);
        resolve();
      };
      const didFailLoad = (event, errorCode, errorDescription, validatedURL, isMainFrame) => {
        clearTimeout(timer);
        if (isMainFrame === false) {
          console.debug(`Smart Link Formatter: Non-main frame load failed for ${validatedURL}: ${errorDescription}. Continuing for main frame.`);
          return;
        }
        window.webContents.removeListener("did-finish-load", didFinishLoad);
        window.webContents.removeListener("did-fail-load", didFailLoad);
        reject(new Error(`Failed to load URL: ${validatedURL} - ${errorDescription} (Code: ${errorCode})`));
      };
      window.webContents.on("did-finish-load", didFinishLoad);
      window.webContents.on("did-fail-load", didFailLoad);
      window.loadURL(url);
    });
  });
}
function electronGetPageTitle(url) {
  return __async(this, null, function* () {
    if (import_obsidian2.Platform.isMobile) {
      console.warn("Smart Link Formatter: Electron not available on mobile platform.");
      return null;
    }
    let electronPkg;
    try {
      electronPkg = require("electron");
    } catch (e) {
      console.warn("Smart Link Formatter: Electron module not available.");
      return null;
    }
    if (!electronPkg || !electronPkg.remote) {
      console.warn("Smart Link Formatter: Electron remote module not available for electronGetPageTitle.");
      return null;
    }
    const { BrowserWindow } = electronPkg.remote;
    let window = null;
    try {
      window = new BrowserWindow({
        width: 1e3,
        height: 600,
        webPreferences: {
          webSecurity: true,
          nodeIntegration: false,
          contextIsolation: true,
          images: false,
          javascript: true
        },
        show: false
      });
      window.webContents.setAudioMuted(true);
      yield loadElectronWindow(window, url);
      const title = window.webContents.getTitle();
      return !blank(title) ? title : null;
    } catch (ex) {
      console.error(`Smart Link Formatter: Error in electronGetPageTitle for ${url}:`, ex);
      return null;
    } finally {
      if (window && !window.isDestroyed()) {
        window.destroy();
      }
    }
  });
}
function fetchTitleWithRequestUrl(urlToFetch) {
  return __async(this, null, function* () {
    var _a, _b, _c, _d, _e;
    try {
      const response = yield (0, import_obsidian2.requestUrl)({ url: urlToFetch, method: "GET" });
      const contentType = (_a = response.headers["content-type"]) == null ? void 0 : _a.toLowerCase();
      if (contentType && !contentType.includes("text/html")) {
        return getUrlFinalSegment(urlToFetch) || urlToFetch;
      }
      const text = response.text;
      const doc = new DOMParser().parseFromString(text, "text/html");
      const titleElement = doc.querySelector("title");
      const actualTitle = (_b = titleElement == null ? void 0 : titleElement.innerText) == null ? void 0 : _b.trim();
      if (!blank(actualTitle)) {
        return actualTitle;
      }
      const noTitleAttr = (_c = titleElement == null ? void 0 : titleElement.getAttribute("no-title")) == null ? void 0 : _c.trim();
      if (!blank(noTitleAttr)) {
        return noTitleAttr;
      }
      const h1Element = doc.querySelector("h1");
      const h1Text = (_d = h1Element == null ? void 0 : h1Element.innerText) == null ? void 0 : _d.trim();
      if (!blank(h1Text)) {
        return h1Text;
      }
      const metaTitleElement = doc.querySelector('meta[property="og:title"], meta[name="twitter:title"], meta[itemprop="name"]');
      const metaTitleContent = (_e = metaTitleElement == null ? void 0 : metaTitleElement.getAttribute("content")) == null ? void 0 : _e.trim();
      if (!blank(metaTitleContent)) {
        return metaTitleContent;
      }
      return urlToFetch;
    } catch (error) {
      console.error(`Smart Link Formatter: Failed to fetch page title via requestUrl for ${urlToFetch}:`, error);
      return urlToFetch;
    }
  });
}
function tryGetContentTypeAndSegment(url) {
  return __async(this, null, function* () {
    var _a;
    try {
      const response = yield (0, import_obsidian2.requestUrl)({ url, method: "HEAD" });
      const contentType = (_a = response.headers["content-type"]) == null ? void 0 : _a.toLowerCase();
      if (contentType && !contentType.includes("text/html")) {
        return getUrlFinalSegment(url) || url;
      }
      return null;
    } catch (err) {
      console.warn(`Smart Link Formatter: HEAD request for ${url} failed or inconclusive. Proceeding with GET. Error:`, err);
      return null;
    }
  });
}
function getPageTitleOrchestrator(url) {
  return __async(this, null, function* () {
    let processedUrl = url;
    if (!(processedUrl.startsWith("http") || processedUrl.startsWith("https"))) {
      processedUrl = "https://" + processedUrl;
    }
    let title = null;
    const nonHtmlTitle = yield tryGetContentTypeAndSegment(processedUrl);
    if (nonHtmlTitle) {
      return escapeMarkdownChars(nonHtmlTitle);
    }
    if (import_obsidian2.Platform.isMobile) {
      title = yield fetchTitleWithRequestUrl(processedUrl);
    } else {
      try {
        title = yield electronGetPageTitle(processedUrl);
      } catch (electronError) {
        console.error(`Smart Link Formatter: electronGetPageTitle failed for ${processedUrl}:`, electronError);
        title = null;
      }
      if (blank(title)) {
        title = yield fetchTitleWithRequestUrl(processedUrl);
      }
    }
    return escapeMarkdownChars(title || processedUrl);
  });
}

// main.ts
function getYouTubeTimestamp(url) {
  let timestamp = url.searchParams.get("t") || url.searchParams.get("time_continue") || "";
  timestamp = timestamp.replace("s", "");
  return Number(timestamp);
}
function formatDate(dateStr) {
  if (dateStr.match(/^\d{8}$/)) {
    return `${dateStr.slice(0, 4)}/${dateStr.slice(4, 6)}/${dateStr.slice(6, 8)}`;
  }
  try {
    const date = new Date(dateStr);
    if (!isNaN(date.getTime())) {
      return date.getFullYear() + "/" + String(date.getMonth() + 1).padStart(2, "0") + "/" + String(date.getDate()).padStart(2, "0");
    }
  } catch (e) {
    console.error("Failed to parse date:", e);
  }
  return dateStr;
}
function formatDuration(totalSeconds) {
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor(totalSeconds % 3600 / 60);
  const seconds = totalSeconds % 60;
  const parts = [];
  if (hours > 0)
    parts.push(hours.toString());
  parts.push(minutes.toString().padStart(hours > 0 ? 2 : 1, "0"));
  parts.push(seconds.toString().padStart(2, "0"));
  return parts.join(":");
}
function escapeMarkdownChars(text) {
  return text.replace(/([\[\]|*_`\\])/g, "\\$1");
}
function generateUniqueToken() {
  const id = `link-placeholder-${Date.now()}_${Math.floor(Math.random() * 1e6)}`;
  return `<span class="link-loading" id="${id}">Loading...</span>`;
}
function fetchYouTubeMetadata(url) {
  return __async(this, null, function* () {
    var _a, _b, _c, _d;
    try {
      const response = yield (0, import_obsidian3.requestUrl)({ url, method: "GET" });
      const html = response.text;
      let playerResponseJson = null;
      try {
        const match = html.match(/var ytInitialPlayerResponse = ({.*?});/);
        if (match && match[1]) {
          playerResponseJson = JSON.parse(match[1]);
        } else {
          const dataMatch = html.match(/var ytInitialData = ({.*?});/);
          if (dataMatch && dataMatch[1]) {
            playerResponseJson = JSON.parse(dataMatch[1]);
          } else {
            console.warn("Could not find ytInitialPlayerResponse or ytInitialData in HTML.");
          }
        }
      } catch (parseError) {
        console.error("Failed to parse YouTube JSON data:", parseError);
        playerResponseJson = null;
      }
      if (playerResponseJson) {
        const videoDetails = playerResponseJson.videoDetails;
        const microformat = (_a = playerResponseJson.microformat) == null ? void 0 : _a.playerMicroformatRenderer;
        if (videoDetails || microformat) {
          const title = (videoDetails == null ? void 0 : videoDetails.title) || ((_b = microformat == null ? void 0 : microformat.title) == null ? void 0 : _b.simpleText);
          const uploader = (videoDetails == null ? void 0 : videoDetails.author) || ((_c = microformat == null ? void 0 : microformat.ownerChannelName) == null ? void 0 : _c.simpleText);
          const description = (videoDetails == null ? void 0 : videoDetails.shortDescription) || ((_d = microformat == null ? void 0 : microformat.description) == null ? void 0 : _d.simpleText);
          const views = videoDetails == null ? void 0 : videoDetails.viewCount;
          const durationSeconds = videoDetails == null ? void 0 : videoDetails.lengthSeconds;
          const uploadDate = microformat == null ? void 0 : microformat.publishDate;
          return {
            title: title ? escapeMarkdownChars(title) : void 0,
            uploader: uploader ? escapeMarkdownChars(uploader) : void 0,
            channel: uploader ? escapeMarkdownChars(uploader) : void 0,
            description: description ? escapeMarkdownChars(description) : void 0,
            views: views ? parseInt(views).toLocaleString() : void 0,
            duration: durationSeconds ? formatDuration(parseInt(durationSeconds)) : void 0,
            upload_date: uploadDate ? formatDate(uploadDate.replace(/-/g, "")) : void 0
          };
        } else {
          console.warn("Could not find videoDetails or microformat in JSON data.");
        }
      }
    } catch (error) {
      console.error(`Failed to fetch or parse YouTube metadata for ${url}:`, error);
      new import_obsidian3.Notice("Failed to fetch YouTube data.", 3e3);
    }
    return {
      title: escapeMarkdownChars(url),
      uploader: void 0,
      channel: void 0,
      description: void 0,
      views: void 0,
      duration: void 0,
      upload_date: void 0
    };
  });
}
var SmartLinkFormatterPlugin = class extends import_obsidian3.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new LinkFormatterSettingTab(this.app, this));
      this.registerEvent(this.app.workspace.on("editor-paste", (evt, editor) => {
        this.handlePaste(evt, editor);
      }));
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  handlePaste(evt, editor) {
    return __async(this, null, function* () {
      if (!this.settings.autoLink)
        return;
      if (!evt.clipboardData)
        return;
      const clipboardText = evt.clipboardData.getData("text/plain");
      if (!clipboardText.match(/^https?:\/\//))
        return;
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile)
        return;
      const cursor = editor.getCursor();
      const line = editor.getLine(cursor.line);
      if (!editor.somethingSelected()) {
        const potentialLinkMatch = line.substring(0, cursor.ch).match(/\[.*?\]\($/);
        if (potentialLinkMatch && line[cursor.ch] === ")") {
          evt.preventDefault();
          editor.replaceSelection(clipboardText);
          return;
        }
        const charBefore = cursor.ch > 0 ? line[cursor.ch - 1] : "";
        const charAfter = cursor.ch < line.length ? line[cursor.ch] : "";
        if (charBefore === "`" || charAfter === "`") {
          evt.preventDefault();
          editor.replaceSelection(clipboardText);
          return;
        }
      }
      evt.preventDefault();
      const placeholder = generateUniqueToken();
      const selectionStartCursor = editor.getCursor("from");
      const startOffset = editor.posToOffset(selectionStartCursor);
      editor.replaceSelection(placeholder);
      const placeholderStartPos = editor.offsetToPos(startOffset);
      const placeholderEndPos = editor.offsetToPos(startOffset + placeholder.length);
      editor.setCursor(placeholderEndPos);
      try {
        const url = new URL(clipboardText);
        const blacklist = this.settings.blacklistedDomains.split(",").map((domain) => domain.trim()).filter((domain) => domain.length > 0);
        if (blacklist.some((domain) => url.hostname.includes(domain))) {
          editor.replaceRange(clipboardText, placeholderStartPos, placeholderEndPos);
          return;
        }
      } catch (e) {
        console.error("Failed to parse URL for blacklist check:", e);
        editor.replaceRange(clipboardText, placeholderStartPos, placeholderEndPos);
        return;
      }
      try {
        if (clipboardText.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)[a-zA-Z0-9_-]+/)) {
          const metadata = yield fetchYouTubeMetadata(clipboardText);
          const urlObj = new URL(clipboardText);
          const seconds = getYouTubeTimestamp(urlObj);
          let timestampStr = "";
          if (seconds) {
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor(seconds % 3600 / 60);
            const secs = seconds % 60;
            timestampStr = hours > 0 ? `@${hours}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}` : `@${mins}:${secs.toString().padStart(2, "0")}`;
          }
          let formattedText = this.settings.printCommand;
          formattedText = formattedText.replace("{title}", metadata.title || "");
          formattedText = formattedText.replace("{channel}", metadata.channel || "");
          formattedText = formattedText.replace("{uploader}", metadata.uploader || "");
          formattedText = formattedText.replace("{description}", metadata.description || "");
          formattedText = formattedText.replace("{views}", metadata.views || "");
          formattedText = formattedText.replace("{duration}", metadata.duration || "");
          formattedText = formattedText.replace("{upload_date}", metadata.upload_date || "");
          formattedText = formattedText.replace("{url}", clipboardText);
          formattedText = formattedText.replace("{timestamp}", timestampStr);
          const linkMatch = formattedText.match(/\[(.*?)\]/);
          let finalFormattedLink = formattedText;
          if (linkMatch && linkMatch[1]) {
            const linkContent = linkMatch[1];
            const firstBracketIndex = formattedText.indexOf(linkMatch[0]);
            const suffix = formattedText.slice(firstBracketIndex + linkMatch[0].length).trim();
            finalFormattedLink = `[${linkContent}](${clipboardText})${suffix ? " " + suffix : ""}`;
          } else {
            finalFormattedLink = `[${formattedText.trim()}](${clipboardText})`;
          }
          this.replacePlaceholder(activeFile, placeholder, finalFormattedLink, editor);
        } else {
          const title = yield getPageTitleOrchestrator(clipboardText);
          let formattedText = this.settings.defaultLinkFormat;
          formattedText = formattedText.replace("{title}", title);
          formattedText = formattedText.replace("{url}", clipboardText);
          const linkMatch = formattedText.match(/\[(.*?)\]/);
          let finalFormattedLink = "";
          if (linkMatch && linkMatch[1]) {
            const linkContent = linkMatch[1];
            const firstBracketIndex = formattedText.indexOf(linkMatch[0]);
            const suffix = formattedText.slice(firstBracketIndex + linkMatch[0].length).trim();
            finalFormattedLink = `[${linkContent}](${clipboardText})${suffix ? " " + suffix : ""}`;
          } else {
            finalFormattedLink = `[${formattedText.trim()}](${clipboardText})`;
          }
          this.replacePlaceholder(activeFile, placeholder, finalFormattedLink, editor);
        }
      } catch (error) {
        console.error("Failed to format link:", error);
        new import_obsidian3.Notice("Failed to format link");
        const errorFormattedText = `[Failed to fetch title](${clipboardText})`;
        this.replacePlaceholder(activeFile, placeholder, errorFormattedText, editor);
      }
    });
  }
  replacePlaceholder(file, placeholder, newText, editor) {
    return __async(this, null, function* () {
      try {
        const editorContent = editor.getValue();
        if (editorContent.includes(placeholder)) {
          const startPos = editor.offsetToPos(editorContent.indexOf(placeholder));
          const endPos = editor.offsetToPos(editorContent.indexOf(placeholder) + placeholder.length);
          editor.replaceRange(newText, startPos, endPos);
        } else {
          console.warn("Smart Link Formatter: Placeholder not found in editor or vault content.");
        }
      } catch (error) {
        console.error("Smart Link Formatter: Failed to replace placeholder.", error);
        new import_obsidian3.Notice("Error updating link in file.");
      }
    });
  }
};

/* nosourcemap */